name: Probe provider

on:
  workflow_dispatch:
    inputs:
      provider:
        description: "Which provider to probe"
        required: true
        default: groq
        type: choice
        options: [groq, gemini]
      prompt:
        description: "Prompt to send"
        required: false
        default: "Say: hello from doomarena-lab"
      groq_model:
        description: "Groq model (OpenAI-compatible)"
        required: false
        default: "llama-3.1-8b-instant"

permissions:
  contents: read

jobs:
  probe:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Select provider
        run: |
          echo "Provider: ${{ inputs.provider }}"
          echo "Prompt:   ${{ inputs.prompt }}"
          echo "Groq model: ${{ inputs.groq_model }}"

      - name: Probe Groq (OpenAI-compatible)
        if: ${{ inputs.provider == 'groq' }}
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          MODEL: ${{ inputs.groq_model }}
          PROMPT: ${{ inputs.prompt }}
        run: |
          set -euo pipefail
          if [ -z "$GROQ_API_KEY" ]; then
            echo "::warning::GROQ_API_KEY is not set. Add it in Settings > Secrets and variables > Actions."
            exit 0
          fi
          echo "Calling Groq model: $MODEL"
          echo "PROMPT: $PROMPT"
          RESP_FILE="$(mktemp /tmp/groq_response.XXXXXX.json)"
          PAYLOAD="$(jq -nc --arg m "$MODEL" --arg p "$PROMPT" '{model:$m, messages:[{role:"user", content:$p}], max_tokens:64, temperature:0.2}')"
          REPLY_TEXT="$(curl -sS https://api.groq.com/openai/v1/chat/completions \
            -H "Authorization: Bearer $GROQ_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" \
            | tee "$RESP_FILE" \
            | jq -r '
              if .error then
                "ERROR: " + (.error.message // .error.code // .error.type // (.error | tostring))
              else
                .choices[0].message.content // ""
              end
            ' )" || {
            echo "::error::Failed to call Groq API"
            exit 1
          }
          echo "RAW_RESPONSE_JSON<<EOF"
          cat "$RESP_FILE"
          echo "EOF"
          if [ -z "$REPLY_TEXT" ]; then
            echo "REPLY: <no content>"
            exit 1
          fi
          if [ "${REPLY_TEXT#ERROR: }" != "$REPLY_TEXT" ]; then
            echo "$REPLY_TEXT"
            exit 1
          fi
          echo "REPLY: $REPLY_TEXT"
          PROMPT_TOKENS="$(jq -r '.usage.prompt_tokens // 0' "$RESP_FILE")"
          COMPLETION_TOKENS="$(jq -r '.usage.completion_tokens // 0' "$RESP_FILE")"
          TOTAL_TOKENS="$(jq -r '.usage.total_tokens // 0' "$RESP_FILE")"
          echo "USAGE: prompt=$PROMPT_TOKENS completion=$COMPLETION_TOKENS total=$TOTAL_TOKENS"
          echo "Saved raw response to $RESP_FILE"

      - name: Probe Gemini (REST)
        if: ${{ inputs.provider == 'gemini' }}
        env:
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
          PROMPT: ${{ inputs.prompt }}
        run: |
          if [ -z "$GOOGLE_API_KEY" ]; then
            echo "::warning::GOOGLE_API_KEY is not set. Add it in Settings > Secrets and variables > Actions."
            exit 0
          fi
          echo "Calling Gemini 1.5 Flash"
          RESP="$(curl -sS -X POST \
            -H "Content-Type: application/json" \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=$GOOGLE_API_KEY" \
            -d "{\"contents\":[{\"parts\":[{\"text\":\"$PROMPT\"}]}]}")" || {
            echo "::error::curl failed"
            exit 1
          }
          echo "RAW_RESPONSE_JSON<<EOF"
          echo "$RESP"
          echo "EOF"
          echo "$RESP" | python - <<'PY'
          import json, sys

          data = json.load(sys.stdin)
          error = data.get("error")
          if error:
              print(f"ERROR: {error}")
              sys.exit(1)

          content_text = None
          candidates = data.get("candidates") or []
          if candidates:
              content = candidates[0].get("content") or {}
              parts = content.get("parts") or []
              if parts:
                  content_text = parts[0].get("text")

          if content_text:
              print(f"REPLY: {content_text}")
          else:
              print("REPLY: <no content>")
              sys.exit(1)
          PY
